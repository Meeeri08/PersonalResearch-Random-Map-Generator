# Procedural Map Generation
 
I am [Pablo Galve](https://www.linkedin.com/in/pablogalve), student of the
[Bachelor’s Degree in
Video Games Programming and Development](https://www.citm.upc.edu/ing/estudis/graus-videojocs/) by UPC at CITM). 

This content is generated for the second year’s subject Project 2, under supervision of lecturer
[Marc Garrigó](https://www.linkedin.com/in/mgarrigo).

## What are procedural generated maps?
Procedural maps are generated by a computer instead of by a person.

|<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/procedural_island_01.gif?raw=true" alt="Height Formula" width="400" height="200">|<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/procedural_island_02.gif?raw=true" alt="Height Formula" width="400" height="200">|
|:---:|:---:|
|Procedural Island|Procedural Island|

## Why to use procedural generated maps?
Manually created maps are limited to our budget (both in time and money). We can create awesome levels but we can't design an infinite map as it would consume endless production resources.   

What if we could create a different map in each game? What if we could have endless different combinations?
Well, we can do it with procedural map generation.
Let's see...

## Characteristics of a procedural generated map
### Pros and Cons of using them
#### Pros of procedural algorithms
- New challenges and experiences on each game.
- Users can play for years as it's a never ending different experience.
- Maps can be adjust its difficulty based on the player.
- Monetization can be dramatically increased.
#### Cons of procedural algorithms
- You can't design it 100% as you want, that's why narrative focused games don't use it.
- It's difficult to get extreme details.

### When is it useful to use procedural methodologies instead of doing maps manually?
Well, certainly we should use different methodologies depending on the project requirements.

* Manual
  * If it's a small game.
  * If it needs to follow a defined story/narrative.
  * If you need extreme details.
* Procedural
  * If it's an open-world game.
  * If you want endless different map combinations.
  * If you want every game to be unique.


It is usually used for creating the environment, spawning enemies or looting objects.
However, it can be used for anything as you could procedurally generate an entire universe.

We also have to take into account that these methodologies are not trully random but quasi-random and they use content generated beforehand by developers. The computed chooses where to allocate each element of even combine parts of elements to generate more complex objects or assets.

## Different approaches by different games
The most well-known game using procedural map generation is Minecraft by Mojang. 
Other games that have used procedural mothodologies for its entire maps or for some of its parts are Civilization V, Dwarf Fortress, Spore and Diablo

|<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/procedural_minecraft.jpg?raw=true" alt="Height Formula" width="400" height="200">|<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/procedural_spore.PNG?raw=true" alt="Height Formula" width="400" height="200">|<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/procedural_no_man_sky.jpg?raw=true" alt="Height Formula" width="400" height="200">|
|:---:|:---:|:---:|
|Minecraft|Spore|No Man's Sky|

### Different algorithms
#### Binary space partitioning for Dungeons
This is probably one of the easiest methods to achieve procedural map generation for dungeons, but it's also really simple.

Firstly, we have an empty giant room that we'll use to create the map. We name that giant room 1.
We need to divide our available big room in different rooms using binary space partitioning.
Space sizes may be different for each space.
* We create childs 2 and 3 from parent 1.
* We create childs 4 and 5 from parent 2.
* We create childs 6 and 7 from parent 3.
* We create childs 8 and 9 from parent 5.
We divide until we can't divide anymore or until we reach a defined maximum number of spaces.
We'll get something like that:

<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/Binary_space_partitioning_concept__01_dividing_space.PNG?raw=true" alt="Dividing Space" width="400" height="200">

Then, once we have the space divided we generate separated rooms inside each space.
In order to that we generate a room of the space' size but leaving a margin in order to leave some empty spaces without rooms.
For example, we can achieve that by giving a 10% margin between space wall and room wall.

<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/Binary_space_partitioning_concept__02_rooms.PNG?raw=true" alt="Generate rooms" width="400" height="200">

Finally, we create corridors to connect all the rooms and make sure that the entire map is reachable.
In order to achieve that, we start with the youngest child and we connect chils from the same parent.
* 8 and 9
* 4 and 5. But 4 is composed by 8 and 9, so we create a corridor between 5 and (8 or 9, can be choosed randomly).
* 6 and 7
* 2 and 3. Both 2 and 3 are groups of rooms so we need to connect one room from each group.

<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/Binary_space_partitioning_concept__03_corridors.PNG?raw=true" alt="Corridors" width="400" height="200">

And we could have a result like that:

<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/dungeon.PNG?raw=true" alt="Dungeon" width="400" height="200">

#### Interpretive 
Used by Spore.

They generate creatures with interpretive methodologies.

|![Spore](https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/Interpretive_spore_02.PNG?raw=true)|![Motion Graphics](https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/Interpretive_motion.PNG?raw=true)|
|:---:|:---:|
|Spore|Motion Graphics|

#### Perlin Noise
We'll be using this method for this tutorial. Explained below.

## Perlin Noise Explained in Depth
Normal noise is what we could see in an out of sync TV.
Perlin noise is a smoother type of noise.
|![Normal noise](https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/noise_normal.PNG?raw=true)|![Perlin noise](https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/noise_perlin.PNG?raw=true)|
|:---:|:---:|
|Normal Noise|Perlin Noise|

We only need to store a seed and a math formula in order to procedurally generate an entire world as they are not located in a server but generated in real-time with your data.
What we do is introduce coordinates and our seed number, and the program will return as the output the map height at our desired coordinates. If we change the seed number, the generated world will be entirely different and unique.

We interpretate Perlin noise as numbers, I mean:

The white areas are 0, the black areas are 1 and the grey areas are something between 0 and 1.

This is a perlin noise interpretation in 3D:

<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/height_formula.PNG?raw=true" alt="Height Formula" width="400" height="200">

Then, we interpretate numbers to spawn terrains. For this tutorial I used the following data

<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/terrain_data.PNG?raw=true" alt="Height Formula" width="400" height="200">

That was the result:

<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/procedural_map_03.PNG?raw=true" alt="Height Formula" width="400" height="200">

## TODOs

To follow the tutorial you can download the code here:

https://github.com/pablogalve/Random-Map-Generation/releases

## TODO 1: Generate Perlin Noise
Output: You won’t see anything on screen yet. But don't worry, it's working.

## TODO 2.1: Store Perlin Noise 
Output: You will see values in console and a height_map on screen

|<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/todo_2_1.PNG?raw=true" alt=" " width="400" height="200">|<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/height_map_error.PNG?raw=true" alt=" " width="400" height="200">|
|:---:|:---:|
| Console View | Screen View |

## TODO 2.2: Adjust Perlin Noise to a 0-1 range
Output: You will see values from 0 to 1 in console

|<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/todo_2_2.PNG?raw=true" alt=" " width="400" height="200">|<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/height_map_perlin_noise.PNG?raw=true" alt=" " width="400" height="200">|
|:---:|:---:|
| Console View | Screen View |

## TODO 3: Draw Map from height_map
Output: You will see a map on screen

<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/procedural_map_04.PNG?raw=true" alt="Height Formula" width="400" height="200">
## TODO 4: Generate a random seed
Output: You will the the same, but don't worry!

## TODO 5: Use the seed
Output: That's all! You have random maps generated procedurally!

|![Map 1](https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/procedural_map_01.PNG?raw=true)|![Map 2](https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/procedural_map_02.PNG?raw=true)|
|:---:|:---:|
|Map 1|Map 2|

# Solutions in video tutorial form

[![Procedural Map Generation - Solution to exercises](https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/tutorial_youtube.PNG?raw=true)](https://www.youtube.com/watch?v=CoB_M4Tun4s&feature=youtu.be "Procedural Map Generation - Solution to exercises")

## Theory on how to do Infinite Worlds
It could seem difficult to achieve, but it is not.
You should only need two things
- Occlusion Culling
- Generate Perlin Noise only for all the coordinates seen on screen

### Occlusion Culling
Neither computers nor servers can manage the computational power of storing an entire universe or world.

Well, some of them may be able to do it, but is really far from being efficient.

That's why you should render only what is on screen.

That way you save memory and prepare the program for generating an infinite world.

### Perlin Noise Generation
In our tutorial we limited the map from coordinates [0][0] to [100][100].

In order to make an infinite world you would need a height_map array that covers visible screen.

When you move the camera you have to unload the map areas that you are now not seeing and generate the new areas that you are exploring- 

# Bibliography
I used [Fast c++ Noise Library by Jordan Peck](https://github.com/Auburns/FastNoise)

You can get additional information here:

Video: ["Sunny Valley Studio" video series on youtube.](https://www.youtube.com/watch?v=VnqN0v95jtU)

Video: [The Happie Cat: How Procedurally Generated Terrain Works](https://www.youtube.com/watch?v=JdYkcrW8FBg)

Video: [Coding Challenge #10 2D Terrain Generation using Perlin Noise](https://www.youtube.com/watch?v=jv6YT9pPIHw)


